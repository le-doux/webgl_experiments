<!DOCTYPE HTML>
<html>
	<head>
		<style>
			#glCanvas {
				width: 640px;
				height: 640px;
				background: black;
			}
		</style>
		<script>

		function start() {
			console.log("start");

			var canvas = document.getElementById("glCanvas");
			var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

			if (gl) {
				console.log("got webgl context");

				gl.canvas.width = 640;
				gl.canvas.height = 640;

				var vertShaderSrc = document.getElementById("vert").text;
				var fragShaderSrc = document.getElementById("frag").text;

				console.log("loaded shader sources");
				console.log(vertShaderSrc);

				var vertShader = createShader(gl, gl.VERTEX_SHADER, vertShaderSrc);
				var fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSrc);

				console.log("created shaders!");

				var program = createProgram(gl, vertShader, fragShader);

				console.log('created shader program!');

				//get uniform locations
				var matrixUniform = gl.getUniformLocation(program, "u_matrix");

				var positionAttrib = gl.getAttribLocation(program, "a_position");

				console.log("position attrib " + positionAttrib);

				var positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				
				// var positions = [ // quad that covers the whole screen
				// 	0, 0,
				// 	0, 1,
				// 	1, 0,
				// 	0, 1, 
				// 	1, 0,
				// 	1, 1
				// ];

				//cube
				var vertices = [
				  // Front face
				  -1.0, -1.0,  1.0,
				   1.0, -1.0,  1.0,
				   1.0,  1.0,  1.0,
				  -1.0, -1.0,  1.0,
				   1.0,  1.0,  1.0,
				  -1.0,  1.0,  1.0,
				  
				  // Back face
				  -1.0, -1.0, -1.0,
				  -1.0,  1.0, -1.0,
				   1.0,  1.0, -1.0,
				  -1.0, -1.0, -1.0,
				   1.0,  1.0, -1.0,
				   1.0, -1.0, -1.0,
				  
				  // Top face
				  -1.0,  1.0, -1.0,
				  -1.0,  1.0,  1.0,
				   1.0,  1.0,  1.0,
				  -1.0,  1.0, -1.0,
				   1.0,  1.0,  1.0,
				   1.0,  1.0, -1.0,
				  
				  // Bottom face
				  -1.0, -1.0, -1.0,
				   1.0, -1.0, -1.0,
				   1.0, -1.0,  1.0,
				  -1.0, -1.0, -1.0,
				   1.0, -1.0,  1.0,
				  -1.0, -1.0,  1.0,
				  
				  // Right face
				   1.0, -1.0, -1.0,
				   1.0,  1.0, -1.0,
				   1.0,  1.0,  1.0,
				   1.0, -1.0, -1.0,
				   1.0,  1.0,  1.0,
				   1.0, -1.0,  1.0,
				  
				  // Left face
				  -1.0, -1.0, -1.0,
				  -1.0, -1.0,  1.0,
				  -1.0,  1.0,  1.0,
				  -1.0, -1.0, -1.0,
				  -1.0,  1.0,  1.0,
				  -1.0,  1.0, -1.0
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); //note: look up static draw

				console.log("buffer data loaded");

				gl.enable(gl.DEPTH_TEST);
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

				console.log("viewport set");

				gl.clearColor(0,0,0,1);
				gl.clear(gl.COLOR_BUFFER_BIT);

				console.log("clear!");

				gl.useProgram(program);
				gl.enableVertexAttribArray(positionAttrib); // this tells gl which attribute to use for array methods
				gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer); // don't really need to bind again (but would if had multiple buffers)
				var size = 3;
				var type = gl.FLOAT;
				var normalize = false;
				var stride = 0;
				var offset = 0;
				gl.vertexAttribPointer(positionAttrib, size, type, normalize, stride, offset);

				console.log("use program and enable vertex attrib array");

				setInterval(function() {
					gl.clearColor(0,0,0,1);
					gl.clear(gl.COLOR_BUFFER_BIT);

					//set uniforms
					var t = Date.now();
					// console.log(t);
					var d = ((Math.sin( (t / 10000) * Math.PI * 2 )) + 1) / 2;
					var angle = d * Math.PI * 2;
					// console.log(d);
					// console.log(angle);
					// console.log("---");
					var ca = Math.cos( angle );
					var sa = Math.sin( angle );
					var scale = 0.5;
					var matrix = [ca * scale,0,sa * scale,0, 0,1 * scale,0,0, -sa * scale,0,ca * scale,0, 0,0,0,1];
					gl.uniformMatrix4fv(matrixUniform, false, matrix);

					var primitiveType = gl.TRIANGLES;
					var offset = 0;
					var count = 6 * 6;
					gl.drawArrays(primitiveType, offset, count);

					// console.log("drawn!");

				}, -1);
			}
			else {
				console.log("failed to get webgl context");
			}
		}

		function createShader(gl, type, source) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if (success) {
				return shader;
			}
			else {
				console.log(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);	
			}
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);

			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if (success) {
				return program;
			}
			else {
				console.log(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);	
			}
		}
		</script>
		<script id="vert" type="glsl">
			attribute vec4 a_position;
			uniform mat4 u_matrix;
			varying vec4 vColor;
			void main() {
				gl_Position = a_position * u_matrix; //* mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0.5,0.5,0.5,1);
				float d = 0.5 + (a_position.z + 0.5) * 0.4; //0.2 + ((a_position.z + 0.5) / 1.0) * 0.8;
				vColor = vec4(d,d,d,1);
			}
		</script>
		<script id="frag" type="glsl">
			precision mediump float;
			varying vec4 vColor;
			void main() {
				gl_FragColor = vColor;// vec4(1,0,0,1);
			}
		</script>
	</head>
	<body onload="start();">
		<canvas id="glCanvas"></canvas>
	</body>
</html>