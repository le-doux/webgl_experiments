<!DOCTYPE HTML>
<html>
	<head>
		<style>
			#glCanvas {
				width: 1136px;
				height: 640px;
				background: black;
			}
		</style>
		<script>
		/*
		IDEAS & QUESTIONS
		- layers
		- static background
		- tiles
		- pre-rendered animations
		- can anything be dynamic?
		- what is pre-render perf like?
		- will it work on mobile?
		- post processing effects?
		- 2d lightmap?

		NOTES
		- texture coords are [0,1]
		- gl_FragCoord are in pixels
		- data format for RGB is weird (using RGBA instead)
		*/

		var positionAttrib; //hack - need a way for this NOT to be global
		var texCoordAttrib;

		function start() {
			console.log("start");

			var canvas = document.getElementById("glCanvas");
			var gl = canvas.getContext('webgl');

			if (gl) {
				console.log("got webgl context");

				gl.canvas.width = 1136;
				gl.canvas.height = 640;

				// need this for transparency on sprites
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
				gl.enable( gl.BLEND );

				var vertShaderSrc = document.getElementById("vert").text;
				var fragShaderSrc = document.getElementById("frag").text;

				console.log("loaded shader sources");
				console.log(vertShaderSrc);

				var vertShader = createShader(gl, gl.VERTEX_SHADER, vertShaderSrc);
				var fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSrc);

				console.log("created shaders!");

				var program = createProgram(gl, vertShader, fragShader);

				console.log('created shader program!');

				positionAttrib = gl.getAttribLocation(program, "a_position");

				console.log("position attrib " + positionAttrib);

				texCoordAttrib = gl.getAttribLocation(program, "a_tex");

				console.log("tex coord attrib " + texCoordAttrib);

				// var positionBuffer = gl.createBuffer();
				// gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				// var positions = [ // quad that covers the whole screen
				// 	-1, -1, // 0
				// 	-1, 1, // 1
				// 	1, -1, // 2
				// 	-1, 1, // 1
				// 	1, -1, // 2
				// 	1, 1 // 3
				// ];
				// gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW); //note: look up static draw

				var poly = [ 0,0, 100,50, 20,100, 0,0 ];
				var texture = new Texture(gl, 100, 100);
				drawPolygonOnTexture( poly, texture );

				var poly2 = [33,0, 66,0, 100,33, 100,66, 66,100, 33,100, 0,66, 0,33, 33,0];
				var texture2 = new Texture(gl, 100, 100);
				drawPolygonOnTexture( poly2, texture2 );

				var quad = new QuadBuffer(gl, [ {x:-200,y:-200}, {x:-200,y:200}, {x:200,y:-200}, {x:200,y:200} ], texture);
				console.log(quad.points);
				var quad2 = new QuadBuffer(gl, [ {x:-500,y:-100}, {x:-500,y:0}, {x:-400,y:-100}, {x:-400,y:0} ], texture2);
				console.log(quad2.points);

				console.log("buffer data loaded");

				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

				console.log("viewport set");

				gl.clearColor(0,0,1,1);
				gl.clear(gl.COLOR_BUFFER_BIT);

				console.log("clear!");

				gl.useProgram(program);
				// gl.enableVertexAttribArray(positionAttrib); // this tells gl which attribute to use for array methods
				// gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer); // don't really need to bind again (but would if had multiple buffers)
				
				// var size = 2;
				// var type = gl.FLOAT;
				// var normalize = false;
				// var stride = 0;
				// var offset = 0;
				// gl.vertexAttribPointer(positionAttrib, size, type, normalize, stride, offset);

				console.log("use program and enable vertex attrib array");

				// screen size
				var screenUniform = gl.getUniformLocation(program, "u_screen");
				gl.uniform2f(screenUniform, gl.canvas.width, gl.canvas.height);

				setInterval( function() {
					// console.log("update!");

					gl.clearColor(0,0,1,1);
					gl.clear(gl.COLOR_BUFFER_BIT);

					// var primitiveType = gl.TRIANGLES;
					// var offset = 0;
					// var count = 6;
					// gl.drawArrays(primitiveType, offset, count);
					quad.Draw();
					quad2.Draw();
				}, 10 );
			}
			else {
				console.log("failed to get webgl context");
			}
		}

		function QuadBuffer(gl, points, texture) {
			this.points = points;

			// convert quad into two triangles
			var positions = [ points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, 
								points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y ];

			// load positions
			gl.enableVertexAttribArray( positionAttrib ); // this tells gl which attribute to use for array methods
			var positionBuffer = gl.createBuffer();
			// console.log(positionBuffer);
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( positions ), gl.STATIC_DRAW); //note: look up static draw


			// hacky tex stuff
			var texCoords = [ {x:0,y:0}, {x:0,y:1}, {x:1,y:0}, {x:1,y:1} ];
			var texPositions = [ texCoords[0].x, texCoords[0].y, texCoords[1].x, texCoords[1].y, texCoords[2].x, texCoords[2].y, 
								texCoords[1].x, texCoords[1].y, texCoords[2].x, texCoords[2].y, texCoords[3].x, texCoords[3].y ];

			console.log(texPositions);

			gl.enableVertexAttribArray( texCoordAttrib ); // this tells gl which attribute to use for array methods
			var texCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( texPositions ), gl.STATIC_DRAW);

			// textureStuff(gl); // test

			this.Draw = function() {
				texture.Bind();

				// position buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

				var size = 2;
				var type = gl.FLOAT;
				var normalize = false;
				var stride = 0;
				var offset = 0;
				gl.vertexAttribPointer(positionAttrib, size, type, normalize, stride, offset); // required b/c no VAO

				// tex coord buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);

				var size = 2;
				var type = gl.FLOAT;
				var normalize = false;
				var stride = 0;
				var offset = 0;
				gl.vertexAttribPointer(texCoordAttrib, size, type, normalize, stride, offset); // required b/c no VAO

				// draw
				var primitiveType = gl.TRIANGLES;
				var offset = 0;
				var count = 6;
				gl.drawArrays(primitiveType, offset, count);
			}
		}

		function pointInPolygon(point,polygon) {
			var crossCount = 0;

			var pX = point[0];
			var pY = point[1] + 0.5; /* +0.5 avoids corner bug */

			for(var i = 0; i < polygon.length; i+=2) {
				var aX = polygon[i+0];
				var aY = polygon[i+1];

				var bX = polygon[i+2];
				var bY = polygon[i+3];

				var deltaY = (pY - aY) / (bY - aY);
				var lineX = aX + ( (bX - aX) * deltaY );

				var pInsideY = deltaY >= 0 && deltaY <= 1;
				var pGreaterThanX = lineX <= pX;
				var doesCrossLine = pInsideY && pGreaterThanX;

				if(doesCrossLine) crossCount += 1;
			}

			return (crossCount % 2) == 1;
		}

		function drawPolygonOnTexture(polygon,texture) {
			var pixels = texture.GetPixels();
			for(var y = 0; y < texture.height; y++) {
				for(var x = 0; x < texture.width; x++) {
					if( pointInPolygon([x,y],polygon) ) {
						var i = (y * texture.width * 4) + (x * 4);
						pixels[ i+0 ] = 255; // r
						pixels[ i+1 ] = 0;   // g
						pixels[ i+2 ] = 0;   // b
						pixels[ i+3 ] = 255; // a
					}
				}
			}
			texture.SetPixels(pixels);
		}

		function textureStuff(gl) {
			var poly = [ 0,0, 100,50, 20,100, 0,0 ];

			// -- texture stuff ---
			// create texture
			var randomPixels = [];
			var width = 100;
			var height = 100;
			for(var i = 0; i < height; i++) {
				for(var j = 0; j < width; j++) {

					if( pointInPolygon([j,i],poly) ) {
						randomPixels.push( 255 );
						randomPixels.push( 0 );
						randomPixels.push( 0 );
						randomPixels.push( 255 );
					}
					else {
						// randomPixels.push( Math.random() * 255 );
						// randomPixels.push( Math.random() * 255 );
						// randomPixels.push( Math.random() * 255 );
						// randomPixels.push( 255 );
						randomPixels.push( 0 );
						randomPixels.push( 0 );
						randomPixels.push( 0 );
						randomPixels.push( 0 );
					}
				}
			}

			var data = new Uint8Array(randomPixels); // new Uint8Array([255,0,0,255, 0,255,0,255, 0,0,255,255, 0,0,0,255]);
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			// set parameters
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			// upload data into texture
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA /*type*/, width /*width*/, height /*height*/, 0, gl.RGBA /*type*/, gl.UNSIGNED_BYTE, data);
		}

		function Texture( gl, width, height ) {
			this.width = height;
			this.height = height;

			var texId = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texId);
			// set parameters // TODO : verify this is the correct place for these settings
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			var data = [];
			this.GetPixels = function() { return data; };
			this.SetPixels = function(pixelArray) {
				data = pixelArray;
				gl.bindTexture(gl.TEXTURE_2D, texId);
				// upload data into texture
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA /*type*/, width /*width*/, height /*height*/, 0, gl.RGBA /*type*/, gl.UNSIGNED_BYTE, data);
			};
			this.ClearPixels = function() { this.SetPixels( new Uint8Array( width * height * 4 ) ); };

			this.Bind = function() {
				gl.bindTexture(gl.TEXTURE_2D, texId);
			}

			this.ClearPixels();
		}

		function createShader(gl, type, source) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if (success) {
				return shader;
			}
			else {
				console.log(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);	
			}
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);

			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if (success) {
				return program;
			}
			else {
				console.log(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);	
			}
		}
		</script>
		<script id="vert" type="glsl">
			attribute vec4 a_position;
			attribute vec2 a_tex;
			varying vec2 v_tex;
			uniform vec2 u_screen;
			void main() {
				v_tex = a_tex;
				gl_Position = vec4( a_position.x / u_screen.x, a_position.y / u_screen.y, a_position.z, a_position.w );
			}
		</script>
		<script id="frag" type="glsl">
			precision mediump float;
			varying vec2 v_tex;
			uniform sampler2D u_image;
			void main() {
				// vec2 texCoord = (gl_FragCoord.xy) / vec2(1136,640); // ok that was dumb but it got a texture on screen
				gl_FragColor = texture2D(u_image,v_tex);
				// if(gl_FragColor <= 0) discard;
				// gl_FragColor = vec4(v_tex.x, v_tex.y, 0, 1);
			}
		</script>
	</head>
	<body onload="start();">
		<canvas id="glCanvas"></canvas>
	</body>
</html>